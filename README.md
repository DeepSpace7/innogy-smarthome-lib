# Innogy SmartHome Client API JavaScript Library

The official JavaScript library for using the Innogy SmartHome system.

The library abstracts the RESTful Innogy SmartHome Client API in a platform independent JavaScript library, which is distributed for applications using Node.js or the browser.

## Using the Library

(tbd)

### With Node.js

(tbd)

### With a Browser

(tbd)

### Code Examples

In the most trivial case one has all the credentials (for the client and for the user, e.g., the refresh token). Now let's consider that we want to connect to the user's SmartHome system and display all the received events in the browser's console. The following piece of code achieves

```js
var sh = createSmartHome(clientId, clientSecret);
  
sh.connect({
  mode: 'refresh',
  token: refreshToken
}).on('message', function (ev) {
  console.log(ev);
});
```

(tbd)

## Developing

The library itself is written in TypeScript to provide some flexibility regarding the usages. This allows us to safely define some interfaces that can then be consumed by developers. As a consequence the developer does not need to consult the Innogy SmartHome API documentation for some calls, but rather relies on the code completion provided by his/her favorite IDE (which needs to support TypeScript).

As far as the version of TypeScript is concerned we limit the development to TypeScript v2 or higher. To be more specific, currently the following dependency is set in the *project.json*: `^2.0.3`. This will use the most recent major version, i.e., any v2 version of TypeScript that is at least v2.0.3 will be accepted.

### Compiling the Library

Be sure to start by resolving the dependencies of the project. We use `npm` to help us resolving all the packages.

```bash
npm install
```

The library uses the [Gulp](http://gulpjs.com) task runner. By default the following command tries to build everything from scratch (and additionally will try to run the unit tests):

```bash
gulp
```

Be sure to have a working installation of Gulp before running the previous command. Furthermore, more targets exist. Among these targets we find:

* `build` compiles everything
* `build-node` compiles the Node.js version
* `build-dom` compiles the browser version
* `clean` clears the *dist* directory
* `test` compiles and runs the unit tests

More specialized versions of the `clean` command exist, e.g., `clean-node`.

### Unit Tests

The unit tests use the Mocha framework with Chai as BDD / assertion library. A sample test may therefore looks as trivial as the following example:

```ts
const expect = require('chai').expect;

describe('Calculator', () => {
  var subject: Calculator;

  beforeEach(() => {
    subject = new Calculator();
  });

  describe('#add', () => {
    it('should add two numbers together', () => {
      const result = subject.add(2, 3);
      expect(result).to.be.equal(5);
    });
  });
});
```

In this simple snippet we are testing a pseudo `Calculator` class, which may be defined as follows.

```ts
class Calculator {
  add(x: number, y: number): number {
    return x + y;
  }
}
```

The code abstracts the HTTP requester and WebSocket listener. This allows to use a mock version that can be properly examined.

### Code Structure

Besides some of the standard directories we have the following folders:

* `src`, where the source files of the library is placed
* `test`, where the unit tests of the library are placed
* `dist`, where the generated output of the library is stored

The latter is not checked into version control as it can be easily generated by invoking `gulp`.

The `test` folder follows the following conventions:

* Files with unit tests need to end with *Test.ts*
* Mocks should be placed in the `mocks` subdirectory

The `src` folder follows the following conventions:

* Platform-specific code is located in the dedicated `platforms` sub-folder, e.g., `node` for Node.js
* Common utilities are placed in the `utils` folder - these are all functional
* All interfaces modeling the system should be put in the `interfaces` folder

The `interfaces` in the `src` directory are structured as follows:

* Library interfaces are put in the root folder
* Responses to API actions are put in the `responses` directory
* Entities defined in the SmartHome API are placed in the `entities` folder

The latter distinguishes between SmartHome API entities (suffix `Entity`) and standard abstracted types, e.g., `Property` or `Link`. The abstracted types are not suffixed and may appear like standard JavaScript type annotations.

### Error Handling

Correct error handling is quite crucial for this library. The SmartHome system exposes quite a few error codes and messages. Correct reaction once receiving these error codes is of crucial importance.

As an example, the following error codes should be handled by trying to do an initialize once (and then failing):

- 2012: "Session not found"
- 5006: "Controller offline"
- 5002: "Communication with the SHC failed"

(tbd)

### Publishing

The publishing process is based on `npm` again. By using the following command a `*.tgz` file will be created in the root directory.

```bash
npm pack
```

The file follows the rules governed by the `package.json` and `.npmignore` file. Essentially, it will contain the `dist/node` directory's content, the `package.json`, as well as the markdown content files providing some descriptions of the library.

## Contributing

Any contributions are welcome. However, before filing a pull request (PR) an issue should be opened. The issue should contain:

* What improvement / fix is needed
* How the solution will look like
* If on-going: the current process
* Where the improvement is helping or how the bug can be reproduced

The PR needs to contain unit tests to cover the code changes. PRs to the `master` branch cannot be accepted, so please make sure to target the `devel` branch.

More information about our contribution guidelines can be found in the [CONTRIBUTING file](CONTRIBUTING.md).

## License

The library has been licensed under the MIT license. Details are given the [distributed license file](LICENSE.md).
